<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P3 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired.
 * Be sure your writeup still prints legibly. */
header {
  text-align: center;
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P3 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->
Andrew Tran: ant111@pitt.edu, Blaise Kesler: blk56@pitt.edu, Jeremy Wertkin: jdw113@pitt.edu
<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<p>In this section, broadly overview the types of cryptographic techniques that
your group has decided to use to address threats T1â€“T4.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat1">
      <h2>Threat T1: Unauthorized Token Issuance</h2>
<!-- BEGIN CHANGES HERE -->

<p>In our project's current state, nothing is being done to prevent
unauthorized token issuance. The only proof that a group server requires
in order to issue a token is that the user logging in knows their own username.
The only way this could be secure is if we made the assumption that all
clients were trustworthy, but this can not be assumed. A user <em>a</em>
could have knowledge of another user <em>b</em>'s username, and use this
information to trick the group server into issuing <em>b</em>'s token to
<em>a</em>. This threat is extremely problematic. If unauthorized token
issuance is exploited, an attacker could impersonate the admin of a group
server or the owner of a group. This would give the attacker the ability to
steal information they should not have access to and disrupt the system by
doing things like deleting groups, users, and files. For our file sharing
system to be reliable and secure, it must be impossible to exploit the threat
of unauthorized token issuance.</p>

<p>Our solution to prevent exploiting unauthorized token issuance is to implement
a password based authentication system. Changes will need to be made so that the
initial user created when the group server starts for the first time will be given
a password. Whenever a user is created through a client, the new user will be
given a password along with their username. These passwords will not need to be
stored securely on the server, plaintext will suffice. If the group servers can
be trusted and the only attacker in our system is a passive adversary, there is no
reason to hash and salt passwords. The attacker would have to gain access to the
group server's file system in order to obtain the file storing passwords, and this
is not something a passive adversary can do.</p>

<p>To prevent a passive adversary from obtaining a user's password as it travels
along the network, we will be using hybrid cryptography to establish a secure
channel between the client and the group server. To do this, we will use 4096-bit
RSA key pairs and a 256-bit AES key. This should provide a level of encryption
that will be infeasible to break.</p>

<p>An attacker could encrypt an AES key with the user's public key, hijack the communication
between client and group server, and then send the compromised key to the user. The user
would think they are still talking to the server and send the attacker their password.
To prevent this, we could have the group server sign the symmetric key, but this is not a
valid attack in our current threat model, as we are only considering passive adversaries.</p>

<p>All together, our mechanism for preventing unauthorized token issuance will follow these steps:</p>
<ul>
    <li><em>k</em><sub>c</sub>: Client's public key</li>
    <li><em>k</em><sub>c</sub><sup>-1</sup>: Client's private key</li>
    <li><em>k</em><sub>gs</sub>: Group server's public key</li>
    <li><em>k</em><sub>gs</sub><sup>-1</sup>: Group server's private key
</ul>
<ol>
    <li>GS &rarr; C: <em>k</em><sub>gs</sub></li>
    <li>C &rarr; GS: <em>k</em><sub>c</sub></li>
    <li>Group server generates a 256-bit AES key <em>k</em><sub>AES</sub></li>
	<li>GS &rarr; C: { <em>k</em><sub>AES</sub> }<em>k</em><sub>c</sub></li>
    <li>Client decrypts <em>k</em><sub>AES</sub> with <em>k</em><sub>c</sub><sup>-1</sup></li>
    <li>C &rarr; GS: { username || password }<em>k</em><sub>AES</sub>
	<li>Group server decrypts username and password with <em>k</em><sub>AES</sub></li>
    <li>Group server checks password against user's recorded password</li>
    <li>GS &rarr; C: { token }<em>k</em><sub>AES</sub>, { H(token) }<em>k</em><sub>gs</sub><sup>-1</sup></li>
    <li>Client decrypts token with <em>k</em><sub>AES</sub></li>
</ol>

<p>Assuming users are not willingly sharing passwords and we are only protecting
against passive adversaries, this mechanism protects against unauthorized token issuance in
a correct and secure way. The client and group server agree on a symmetric key
when the group server generates and sends it to the client. This key is only used
for this session and user. The client can trust that the symmetric key came from
the group server and was not modified along the way because there are only passive
adversaries in this threat model. The client can trust that no one else has the 
symmetric key because it was encrypted with the client's public key. After this,
all communication between the client and group server is protected through the
agreed upon symmetric key. For a passive adversary to listen in on the conversation,
he would have to either break the initial public key encryption of the symmetric key,
or brute force the symmetric key. With this mechanism in place, a passive adversary
would have to know a victim's password in order to impersonate them and
obtain their token. This could only happen through the victim's own negligence, or by
recording the victims encrypted password and performing an offline attack on the
256-bit AES encryption.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat2">
      <h2>Threat T2: Token Modification/Forgery</h2>
<!-- BEGIN CHANGES HERE -->

<p>Begin this section by describing threat T2. This may include describing
examples of the threat being exploited by an adversary, a short discussion of
why this threat is problematic and needs to be addressed, and/or diagrams
showing how the threat might manifest in your groupâ€™s insecure
implementation.</p>

<p>Next, provide a short description of the mechanism that you chose to
implement to protect against this threat. For interactive protocols, it would be
helpful to provide a diagram explaining the messages exchanged between
participating principals (use html &lt;img&gt; tag to import such images). Be
sure to explain any cryptographic choices that your group makes: What types of
algorithms, modes of operation, and/or key lengths did you choose? Why? If
shared keys are needed, how are they exchanged?</p>

<p>Finally, provide a short argument addressing why your proposed mechanism
sufficiently addresses this particular threat. This argument should address the
correctness of your approach, as well as its overall security. For example, if
your mechanism involves a key agreement or key exchange protocol, you should
argue that both parties agree on the same key (correctnes) and that no other
party can figure out the key (security).</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat3">
      <h2>Threat T3: Unauthorized File Servers</h2>
<!-- BEGIN CHANGES HERE -->

<p>In the project's current build, there is no way to authenticate the file server 
that a user is connecting to, the user simply trusts the machine it's connected to 
is the real file server. The only requirement for a user to connect to a server is 
the IP address and port number of the server. This is not secure because without 
some way to authenticate the server, an attacker can intercept the traffic from a 
user, or multiple users, going to the server through a man-in-the-middle attack. 
By intercepting the traffic, an attacker could impersonate the file server by 
spoofing their IP to match the actual file server. Since users prove their group 
membership using tokens given by the group server, a consequence of an attacker 
impersonating the file server would be stolen user tokens. If a user sends their 
token to an attacker believing they were communicating with the real file server, 
the attacker could take those tokens and send them to the file server impersonating a 
user and giving them access to the user's group files. Users would also accept any 
file the attacker sends. For example, the attacker could send a malicious file with the 
same name as the one the user requested to trick them into opening it.
</p>

<p>
To prevent the issues explained above, we will use a public key authentication 
system similar to SSH using a 4096-bit RSA key pair to authenticate the file server. 
On the initial connection to a file server, the user will request the server's public 
key. The host will send their public key to the user and a truncated hash of the key will be displayed to the user. The user must then
decide whether or not to trust the key. Confirming the validity of the given key 
should be done through another secure channel. If the user chooses to trust the key, 
a challenge is sent to the host from the user. This challenge will contain a random 256-bit nonce (r1) 
as well as a randomely generated AES key. The entire challenge is encrypted with the file server's 
public key. For each challenge, the host must decrypt the challenge using 
their private key, generate another random nonce (r2), encrypt both nonces (r1 and r2) using the 
AES key generated by the user, and send the re-encrypted nonces back to the user. The user 
will then decrypt using their AES key to extract the nonces sent from the host and if the r1 sent from the host 
matches r1 that the user generated for the challenge, the user can be confident 
that the host they are connected to is the real file server The user then sends r2 encryprted 
with the AES key back to the server. The server will then verify r2 and if successful, the server 
sends back an OK response and the challenge is complete. r2 is used to establish freshness The user can then 
save the hash of the public key locally along with the IP address of the file server.
For every subsequent connection, if the hash value of the public key sent from the host matches a saved hash/IP public key verification is skipped.
</p>

<ul>
    <li><em>k</em><sub>fs</sub>: File server's public key</li>
    <li><em>k</em><sub>fs</sub><sup>-1</sup>: File server's private key</li>
	<li><em>k</em><sub>AES</sub>: AES Key</li>
	<li><em>r1</em>: 256-bit Random nonce generated by the user</li>
	<li><em>r2</em>: 256-bit Random nonce generated by the file server</li>
</ul>
<ol>
    <li>FS &rarr; C: <em>k</em><sub>fs</sub></li>
	<li>C decides whether or not to trust <em>k</em><sub>fs</sub></li>
	<li>C generates <em>r1</em></li>
	<li>C generates <em>k</em><sub>AES</sub></li>
    <li>C &rarr; FS: { <em>r1</em> || <em>k</em><sub>AES</sub> }<em>k</em><sub>fs</sub></li>
	<li>FS decrypts { <em>r1</em> || <em>k</em><sub>AES</sub> }<em>k</em><sub>fs</sub> with <em>k</em><sub>fs</sub><sup>-1</sup></li>
	<li>FS generates <em>r2</em></li>
	<li>FS &rarr; C: { <em>r1</em> || <em>r2</em> }<em>k</em><sub>AES</sub></li>
	<li>C decrypts { <em>r1</em> || <em>r2</em> }<em>k</em><sub>AES</sub> with <em>k</em><sub>AES</sub></li>
    <li>C checks for correct <em>r1</em></li>
	<li>C &rarr; FS: { <em>r2</em> }<em>k</em><sub>AES</sub></li>
	<li>FS check for correct <em>r2</em></li>
	<li>FS &rarr; C: { "OK" }<em>k</em><sub>AES</sub></li></li>
</ol>

<p>
The only point of weakness in this mechanism is that a different secure channel is 
needed to validate the key and is also not required to do so. If the file server and 
the user have not already established a shared symmetric key or if the user doesn't 
already know the server's public key, there isn't a way to exchange this information 
that is secure against an active attacker. Relying on another secure channel and 
hoping users will personally verify public keys is the best we can do. So, if we 
assume all users will verify public keys before trusting them, this mechanism will 
allow users to be confident that the host they are connected to is the real file server.
We can assume that the user has a secure means of communicating with the file server admin 
because if these hosts have agreed to share files, they should hava another channel to communicate.
The challenge system is a zero-knowledge proof that allows the file server to prove 
they know the private key that matches the trusted public key. Only the file server 
(who knows <em>k</em><sub>fs</sub><sup>-1</sup>) and the user will know the <em>k</em><sub>AES</sub>
for the session so there is no way a man-in-the-middle can impersonate the file server.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat4">
      <h2>Threat T4: Information Leakage via Passive Monitoring</h2>
<!-- BEGIN CHANGES HERE -->

<p>Begin this section by describing threat T4. This may include describing
examples of the threat being exploited by an adversary, a short discussion of
why this threat is problematic and needs to be addressed, and/or diagrams
showing how the threat might manifest in your groupâ€™s insecure
implementation.</p>

<p>Next, provide a short description of the mechanism that you chose to
implement to protect against this threat. For interactive protocols, it would be
helpful to provide a diagram explaining the messages exchanged between
participating principals (use html &lt;img&gt; tag to import such images). Be
sure to explain any cryptographic choices that your group makes: What types of
algorithms, modes of operation, and/or key lengths did you choose? Why? If
shared keys are needed, how are they exchanged?</p>

<p>Finally, provide a short argument addressing why your proposed mechanism
sufficiently addresses this particular threat. This argument should address the
correctness of your approach, as well as its overall security. For example, if
your mechanism involves a key agreement or key exchange protocol, you should
argue that both parties agree on the same key (correctnes) and that no other
party can figure out the key (security).</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->

<p>Conclude with a paragraph or two discussing the interplay between your
proposed mechanisms, and commenting on the design process that your group
followed. Did you discuss other ideas that didnâ€™t pan out before settling on the
above-documented approach? Did you end up designing a really interesting
protocol suite that addresses multiple threats at once? Use this space to show
off your hard work!</p>

<p>If your group did any extra credit, please discuss that in this section, as
well.</p>

<!-- END CHANGES HERE -->
    </section>
  </body>
</html>
