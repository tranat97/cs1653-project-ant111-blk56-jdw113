<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P3 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired.
 * Be sure your writeup still prints legibly. */
header {
  text-align: center;
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P3 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->
Andrew Tran: ant111@pitt.edu, Blaise Kesler: blk56@pitt.edu, Jeremy Wertkin: jdw113@pitt.edu
<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<p>In this section, broadly overview the types of cryptographic techniques that
your group has decided to use to address threats T1â€“T4.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat1">
      <h2>Threat T1: Unauthorized Token Issuance</h2>
<!-- BEGIN CHANGES HERE -->

<p>In our project's current state, nothing is being done to prevent
unauthorized token issuance. The only proof that a group server requires
in order to issue a token is that the user logging in knows their own username.
The only way this could be secure is if we made the assumption that all
clients were trustworthy, but this can not be assumed. A user <em>a</em>
could have knowledge of another user <em>b</em>'s username, and use this
information to trick the group server into issuing <em>b</em>'s token to
<em>a</em>. This threat is extremely problematic. If unauthorized token
issuance is exploited, an attacker could impersonate the admin of a group
server or the owner of a group. This would give the attacker the ability to
steal information they should not have access to and disrupt the system by
doing things like deleting groups, users, and files. For our file sharing
system to be reliable and secure, it must be impossible to exploit the threat
of unauthorized token issuance.</p>

<p>Our solution to prevent exploiting unauthorized token issuance is to implement
a password based authentication system. Changes will need to be made so that the
initial user created when the group server starts for the first time will be given
a password. These passwords will not be stored as plaintext on the server. If the
passwords were stored in plaintext, an attacker would only need access to the file
containing the passwords to obtain every registered user's password. The group server
will salt and hash passwords (using PBKDF2 to hash) and store the salt and hash in 
the user list. PBKDF2 is a purposefully slow hashing algorithm, this makes it very time
consuming to create a rainbow table. When combined with salting, an attacker would
have to generate a rainbow table for every user in the database in order to break all
of their passwords. Salting also prevents an attacker from seeing that two users have
the same password, protecting against simultaneous attacks.</p>

<p>To prevent a passive adversary from obtaining a user's password as it travels
along the network, we will be using hybrid cryptography to establish a secure
channel between the client and the group server. To do this, we will use 4096-bit
RSA key pairs and a 256-bit AES key. This should provide a level of encryption
that will be infeasible to break.</p>

<p>An attacker could encrypt an AES key with the user's public key, and then send
this to the user. The user would think they are still talking to the server and
send the attacker their password. In order to prevent this, the group server will
send a signature of the hash (SHA-256) of the encrypted AES key along with the
encrypted AES key. In order to verify this signature, the user will have to trust 
the group server's public key. This will be done in a similar method to how SSH
allows users to authenticate servers. The group server will send its public key,
and the client will check to see if it matches the previously recorded public key.
If the client does not have a record for this group server's public key, then the
client will present the key's fingerprint (hash of the public key using SHA-256)
and ask the user if it is correct. At this point it is on the user to contact the
admin of the group server to see if it should be trusted.</p>

<p>All together, our mechanism for preventing unauthorized token issuance will follow these steps:</p>
<ul>
    <li><em>k</em><sub>c</sub>: Client's public key</li>
    <li><em>k</em><sub>c</sub><sup>-1</sup>: Client's private key</li>
    <li><em>k</em><sub>gs</sub>: Group server's public key</li>
    <li><em>k</em><sub>gs</sub><sup>-1</sup>: Group server's private key
</ul>
<ol>
    <li>GS &rarr; C: <em>k</em><sub>gs</sub></li>
    <li>Client ensures group server can be trusted by checking the recorded public key or asking the user</li>
    <li>C &rarr; GS: <em>k</em><sub>c</sub></li>
    <li>Group server generates a 256-bit AES key <em>k</em><sub>AES</sub></li>
    <li>GS &rarr; C: {<em>k</em><sub>AES</sub>}<em>k</em><sub>c</sub>,
        {H({<em>k</em><sub>AES</sub>}<em>k</em><sub>c</sub>)}<em>k</em><sub>gs</sub><sup>-1</sup></li>
	<li>Client computes H({<em>k</em><sub>AES</sub>}<em>k</em><sub>c</sub>) and verifies signature using <em>k</em><sub>gs</sub></li>
    <li>Client decrypts <em>k</em><sub>AES</sub> with <em>k</em><sub>c</sub><sup>-1</sup></li>
    <li>C &rarr; GS: {username}<em>k</em><sub>AES</sub>, {password}<em>k</em><sub>AES</sub></li>
	<li>Group server decrypts username and password with <em>k</em><sub>AES</sub></li>
    <li>Group server salts password with the salt recorded for that username</li>
    <li>Group server hashes the salted password using PBKDF2</li>
    <li>Group server checks hash against user's recorded hash</li>
    <li>GS &rarr; C: {token}<em>k</em><sub>AES</sub>, {H(token)}<em>k</em><sub>gs</sub><sup>-1</sup></li>
    <li>Client decrypts token with <em>k</em><sub>AES</sub></li>
	<li>Client hashes token and verifies signature</li>
</ol>

<p>Assuming users are not storing their passwords in an insecure way or willingly
sharing passwords, this mechanism protects against unauthorized token issuance in
a correct and secure way. The client and group server agree on a symmetric key
when the group server generates and sends it to the client. This key is only used
for this session and user. The client can trust that the symmetric key came from
the group server and was not modified along the way because the group server
signed the hash of the encrypted symmetric key. Only the client can decrypt the
symmetric key because it was encrypted with the client's public key. After this,
all communication between the client and group server is protected through the
agreed upon symmetric key. For a passive adversary to listen in on the conversation,
he would have to either break the initial public key encryption of the symmetric key,
or brute force the symmetric key. The password is salted and hashed before it is
stored, which adds security to the password database. With this mechanism in place,
an attacker would have to know a victim's password in order to impersonate them and
obtain their token. This could only happen through the victim's own negligence, our
authentication protocol does not allow a user's password to be leaked.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat2">
      <h2>Threat T2: Token Modification/Forgery</h2>
<!-- BEGIN CHANGES HERE -->

<p>Begin this section by describing threat T2. This may include describing
examples of the threat being exploited by an adversary, a short discussion of
why this threat is problematic and needs to be addressed, and/or diagrams
showing how the threat might manifest in your groupâ€™s insecure
implementation.</p>

<p>Next, provide a short description of the mechanism that you chose to
implement to protect against this threat. For interactive protocols, it would be
helpful to provide a diagram explaining the messages exchanged between
participating principals (use html &lt;img&gt; tag to import such images). Be
sure to explain any cryptographic choices that your group makes: What types of
algorithms, modes of operation, and/or key lengths did you choose? Why? If
shared keys are needed, how are they exchanged?</p>

<p>Finally, provide a short argument addressing why your proposed mechanism
sufficiently addresses this particular threat. This argument should address the
correctness of your approach, as well as its overall security. For example, if
your mechanism involves a key agreement or key exchange protocol, you should
argue that both parties agree on the same key (correctnes) and that no other
party can figure out the key (security).</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat3">
      <h2>Threat T3: Unauthorized File Servers</h2>
<!-- BEGIN CHANGES HERE -->

<p>Begin this section by describing threat T3. This may include describing
examples of the threat being exploited by an adversary, a short discussion of
why this threat is problematic and needs to be addressed, and/or diagrams
showing how the threat might manifest in your groupâ€™s insecure
implementation.</p>

<p>Next, provide a short description of the mechanism that you chose to
implement to protect against this threat. For interactive protocols, it would be
helpful to provide a diagram explaining the messages exchanged between
participating principals (use html &lt;img&gt; tag to import such images). Be
sure to explain any cryptographic choices that your group makes: What types of
algorithms, modes of operation, and/or key lengths did you choose? Why? If
shared keys are needed, how are they exchanged?</p>

<p>Finally, provide a short argument addressing why your proposed mechanism
sufficiently addresses this particular threat. This argument should address the
correctness of your approach, as well as its overall security. For example, if
your mechanism involves a key agreement or key exchange protocol, you should
argue that both parties agree on the same key (correctnes) and that no other
party can figure out the key (security).</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat4">
      <h2>Threat T4: Information Leakage via Passive Monitoring</h2>
<!-- BEGIN CHANGES HERE -->

<p>Begin this section by describing threat T4. This may include describing
examples of the threat being exploited by an adversary, a short discussion of
why this threat is problematic and needs to be addressed, and/or diagrams
showing how the threat might manifest in your groupâ€™s insecure
implementation.</p>

<p>Next, provide a short description of the mechanism that you chose to
implement to protect against this threat. For interactive protocols, it would be
helpful to provide a diagram explaining the messages exchanged between
participating principals (use html &lt;img&gt; tag to import such images). Be
sure to explain any cryptographic choices that your group makes: What types of
algorithms, modes of operation, and/or key lengths did you choose? Why? If
shared keys are needed, how are they exchanged?</p>

<p>Finally, provide a short argument addressing why your proposed mechanism
sufficiently addresses this particular threat. This argument should address the
correctness of your approach, as well as its overall security. For example, if
your mechanism involves a key agreement or key exchange protocol, you should
argue that both parties agree on the same key (correctnes) and that no other
party can figure out the key (security).</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->

<p>Conclude with a paragraph or two discussing the interplay between your
proposed mechanisms, and commenting on the design process that your group
followed. Did you discuss other ideas that didnâ€™t pan out before settling on the
above-documented approach? Did you end up designing a really interesting
protocol suite that addresses multiple threats at once? Use this space to show
off your hard work!</p>

<p>If your group did any extra credit, please discuss that in this section, as
well.</p>

<!-- END CHANGES HERE -->
    </section>
  </body>
</html>
