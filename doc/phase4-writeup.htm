<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P4 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired */
header {
  text-align: center;
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P4 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->
Andrew Tran: ant111@pitt.edu, Blaise Kesler: blk56@pitt.edu, Jeremy Wertkin: jdw113@pitt.edu
<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<p>We will use our previously defined handshake for file servers to
exchange keys with group servers. Instead of using a single key for
confidentiality, each session will have a confidentiality and an
integrity key. All messages sent after keys have been exchanged
will include an HMAC of the message data and the message number,
preventing message reorder, replay, or modification.</p>

<p>To protect against file leakage, we will be encrypting files
before they are sent to file servers. The group server will have
to manage keys for each group. When a group member is removed from
a group, the group server must generate a new key for that group.</p>

<p>To protect against token theft, tokens will have a new field that
contains the public key fingerprint of the server that the token is
supposed to be used on (this information is sent to the group server
by the client). The fingerprint will be included in the toString of
the token, preventing a rougue file server from modifying the field.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat5">
      <h2>Threat T5: Message Reorder, Replay, or Modification</h2>
<!-- BEGIN CHANGES HERE -->

<p>Begin this section by describing threat T5. This may include describing
examples of the threat being exploited by an adversary, a short discussion of
why this threat is problematic and needs to be addressed, and/or diagrams
showing how the threat might manifest in your group’s implementation from Phase
3.</p>

<p>Next, provide a short description of the mechanism that you chose to
implement to protect against this threat. For interactive protocols, it would be
helpful to provide a diagram explaining the messages exchanged between
participating principals (use html &lt;img&gt; tag to import such images). Be
sure to explain any cryptographic choices that your group makes: What types of
algorithms, modes of operation, and/or key lengths did you choose? Why? If
shared keys are needed, how are they exchanged?</p>

<p>Finally, provide a short argument addressing why your proposed mechanism
sufficiently addresses this particular threat. This argument should address the
correctness of your approach, as well as its overall security. For example, if
your mechanism involves a key agreement or key exchange protocol, you should
argue that both parties agree on the same key (correctnes) and that no other
party can figure out the key (security).</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat6">
      <h2>Threat T6: File Leakage</h2>
<!-- BEGIN CHANGES HERE -->

<!--<p>Begin this section by describing threat T6. This may include describing
examples of the threat being exploited by an adversary, a short discussion of
why this threat is problematic and needs to be addressed, and/or diagrams
showing how the threat might manifest in your group’s implementation from Phase
3.</p> -->

<p>
Currently, all files that are stored on the file server are sent ecrypted by the user using the session AES key. However, the file server decrypts that file and stores the plaintext version of the file. Since the file servers are not trusted, it cannot be assumed that files will not be leaked from these servers. So it does not matter if the transfer of the files from user to server is secure if the files can just be leaked from the server later on.
</p>

<!--<p>Next, provide a short description of the mechanism that you chose to
implement to protect against this threat. For interactive protocols, it would be
helpful to provide a diagram explaining the messages exchanged between
participating principals (use html &lt;img&gt; tag to import such images). Be
sure to explain any cryptographic choices that your group makes: What types of
algorithms, modes of operation, and/or key lengths did you choose? Why? If
shared keys are needed, how are they exchanged?</p> -->

<p>
The solution to this problem is to have only the encrypted version of the files be sent and stored on the file servers. Each file will be encrypted with a key unique to the group that the file belongs to. These keys will be managed by the group server and will never be shared with the file servers. Each group's keys will be generated by the group server and must be requested by users if they want to decrypt a file recieved from a file server. A new key will be generated upon the group's creation and every time a member is removed from the group. Each key will be identified with an integer value that represents which key is being used. For example, the very first key will be key number 1, when a new key is generated, that key will be key number 2, etc. When a new file is being uploaded to a file server, the user must request the most recent key generated, as well as the number corresponding to that key. The user will encrypt the file using that key and send the encrypted version as well as the key number to the file server where both will be saved. When downloading a file, the file server will send the encrypted file as well as the key number associated with that file. The user will take that key number and request that specific key from the group server which can be used to decrypt the file. Note: We are assuming that the file server will always record the correct key number that is associated with the file being saved.
</p>

<ul>
    <li><em>k</em><sub>i</sub>: the group's i<sup>th</sup> key</li>
    <li><em>k</em><sub>n</sub>: the group's most recent key</li>
    <li><em>f</em>: the file</li>
	<li>Note: For the following examples, we assume the user (C) has permissions to access the keys requested and all messages are encrypted with the appropriate session keys:</li>
</ul>
<p>Saving a file to the file server:</p>
<ol>
    <li>C &rarr; GS: request for <em>k</em><sub>n</sub></li>
    <li>GS &rarr; C: <em>k</em><sub>n</sub></li>
	<li>C &rarr; FS: { { f }<em>k</em><sub>n</sub> || n }</li>
</ol>

<p>Downloading a file from the file server:</p>
<ol>
    <li>FS &rarr; C: { { f }<em>k</em><sub>i</sub> || i }</li>
    <li>C &rarr; GS: request for <em>k</em><sub>i</sub></li>
    <li>GS &rarr; C: <em>k</em><sub>i</sub></li>
	<li>C decrypts { f }<em>k</em><sub>i</sub> with <em>k</em><sub>i</sub>
</ol>

<!--<p>Finally, provide a short argument addressing why your proposed mechanism
sufficiently addresses this particular threat. This argument should address the
correctness of your approach, as well as its overall security. For example, if
your mechanism involves a key agreement or key exchange protocol, you should
argue that both parties agree on the same key (correctnes) and that no other
party can figure out the key (security).</p>-->

<p>
Having the file servers only store the encrypted version of the files means that even if data from those servers are leaked, only members of the group the files belong to have access to the keys required to decrypt them. A new key is generated every time a member is removed from a group to ensure there is backward secrecy. All files will be encrypted with the most recent key, but no files need to be reencrypted with the new key. A removed member will still be able to decrypt these old files, but they could have just saved all files they had access to locally before their removal so there is no need to reencrypt them.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat7">
      <h2>Threat T7: Token Theft</h2>
<!-- BEGIN CHANGES HERE -->

<p>If we are not trusting file server admins, letting them gain access to tokens
which could be used to issue commands on any other server in the system is a massive
problem. A file server admin could collect a user's token and then use that token to
delete all the groups the user owns on the group server, or all the files the user has
access to on a different file server.</p>

<p>To prevent this, we will be adding a field to the token called target. The target
field will contain the fingerprint of the server's public key (defined in T3). The token's toString
method will be modified so that it includes this field in the unique identifier. The group server
will sign the token's toString after the target field has been filled, so any other server will
know if the field has been modified. Both the file server and the group server will verify the
signature and check that the target field matches their own public key's fingerprint. This does mean that if the
client wants to connect to a group server and a file server, they will need separate tokens.</p>

<p>This solution provides correctness and security. If the file server trusts the group
server's public key, then it should trust the token has not been modified if the token's
signature can be verified with the trusted public key. If the file server believes that
the token has not been modified, then the file server can trust that the token was created
to be used on their server if the target field of the token matches the fingerprint of their own public key.
With this solution in place, it would not be possible for a file server admin to collect
user's tokens and use them on any other server in the system. The file server admin would
need to obtain the group server's private key in order to change the target field and resign
the token.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->

<p>There is not as much interplay with these proposed mechanisms as there
were with our protocols designed for phase 3. The changes described in T5
affect every message sent, which will have an effect on T6 and T7</p>

<p>Before beginning to write this document, our group met to discuss
possible solutions. We identified our solution for T7 almost immediately,
but the others took more time. It wasn't until after the lectures on TLS
that we were able to figure out a simple solution to T5. Our first
solution to T6 was far too ineffeicent. When a group member was removed,
we were planning on downloading all the files from the file server,
decrypting them with the old key, encrypting them with the new key,
and then uploading them back to the file server. Professor Garrison
mentioned lazy revocation in discord, and we decided that was a much
better solution.</p>

<p>T1 is still protected against because clients still have to
authenticate with a password in order to obtain a token. Tokens
are being signed by the group server, so our solution for
T2 is still in effect. Our handshake with file servers has not
changed (except we are sending two keys instead of one), so
our solution for T3 still applies.
Every message sent is being encrypted, so there should not be any
information leakage (T4).</p>

<!-- END CHANGES HERE -->
    </section>
  </body>
</html>

