<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P4 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired */
header {
  text-align: center;
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P4 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->
Andrew Tran: ant111@pitt.edu, Blaise Kesler: blk56@pitt.edu, Jeremy Wertkin: jdw113@pitt.edu
<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<p>In this section, broadly overview the types of cryptographic techniques that
your group has decided to use to address threats T5–T7.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat5">
      <h2>Threat T5: Message Reorder, Replay, or Modification</h2>
<!-- BEGIN CHANGES HERE -->

<p>Begin this section by describing threat T5. This may include describing
examples of the threat being exploited by an adversary, a short discussion of
why this threat is problematic and needs to be addressed, and/or diagrams
showing how the threat might manifest in your group’s implementation from Phase
3.</p>

<p>Next, provide a short description of the mechanism that you chose to
implement to protect against this threat. For interactive protocols, it would be
helpful to provide a diagram explaining the messages exchanged between
participating principals (use html &lt;img&gt; tag to import such images). Be
sure to explain any cryptographic choices that your group makes: What types of
algorithms, modes of operation, and/or key lengths did you choose? Why? If
shared keys are needed, how are they exchanged?</p>

<p>Finally, provide a short argument addressing why your proposed mechanism
sufficiently addresses this particular threat. This argument should address the
correctness of your approach, as well as its overall security. For example, if
your mechanism involves a key agreement or key exchange protocol, you should
argue that both parties agree on the same key (correctnes) and that no other
party can figure out the key (security).</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat6">
      <h2>Threat T6: File Leakage</h2>
<!-- BEGIN CHANGES HERE -->

<!--<p>Begin this section by describing threat T6. This may include describing
examples of the threat being exploited by an adversary, a short discussion of
why this threat is problematic and needs to be addressed, and/or diagrams
showing how the threat might manifest in your group’s implementation from Phase
3.</p> -->

<p>
Currently, all files that are stored on the file server are sent ecrypted by the user using the session AES key. However, the file server decrypts that file and stores the plaintext version of the file. Since the file servers are not trusted, it cannot be assumed that files will not be leaked from these servers. So it does not matter if the transfer of the files from user to server is secure if the files can just be leaked from the server later on.
</p>

<!--<p>Next, provide a short description of the mechanism that you chose to
implement to protect against this threat. For interactive protocols, it would be
helpful to provide a diagram explaining the messages exchanged between
participating principals (use html &lt;img&gt; tag to import such images). Be
sure to explain any cryptographic choices that your group makes: What types of
algorithms, modes of operation, and/or key lengths did you choose? Why? If
shared keys are needed, how are they exchanged?</p> -->

<p>
The solution to this problem is to have only the encrypted version of the files be sent and stored on the file servers. Each file will be encrypted with a key unique to the group that the file belongs to. These keys will be managed by the group server and will never be shared with the file servers. Each group's keys will be generated by the group server and must be requested by users if they want to decrypt a file recieved from a file server. A new key will be generated upon the group's creation and every time a member is removed from the group. Each key will be identified with an integer value that represents which key is being used. For example, the very first key will be key number 1, when a new key is generated, that key will be key number 2, etc. When a new file is being uploaded to a file server, the user must request the most recent key generated, as well as the number corresponding to that key. The user will encrypt the file using that key and send the encrypted version as well as the key number to the file server where both will be saved. When downloading a file, the file server will send the encrypted file as well as the key number associated with that file. The user will take that key number and request that specific key from the group server which can be used to decrypt the file. Note: We are assuming that the file server will always record the correct key number that is associated with the file being saved.
</p>

<ul>
    <li><em>k</em><sub>i</sub>: the group's i<sup>th</sup> key</li>
    <li><em>k</em><sub>n</sub>: the group's most recent key</li>
    <li><em>f</em>: the file</li>
	<li>Note: For the following examples, we assume the user (C) has permissions to access the keys requested and all messages are encrypted with the appropriate session keys:</li>
</ul>
<p>Saving a file to the file server:</p>
<ol>
    <li>C &rarr; GS: request for <em>k</em><sub>n</sub></li>
    <li>GS &rarr; C: <em>k</em><sub>n</sub></li>
	<li>C &rarr; FS: { { f }<em>k</em><sub>n</sub> || n }</li>
</ol>

<p>Downloading a file from the file server:</p>
<ol>
    <li>FS &rarr; C: { { f }<em>k</em><sub>i</sub> || i }</li>
    <li>C &rarr; GS: request for <em>k</em><sub>i</sub></li>
    <li>GS &rarr; C: <em>k</em><sub>i</sub></li>
	<li>C decrypts { f }<em>k</em><sub>i</sub> with <em>k</em><sub>i</sub>
</ol>

<!--<p>Finally, provide a short argument addressing why your proposed mechanism
sufficiently addresses this particular threat. This argument should address the
correctness of your approach, as well as its overall security. For example, if
your mechanism involves a key agreement or key exchange protocol, you should
argue that both parties agree on the same key (correctnes) and that no other
party can figure out the key (security).</p>-->

<p>
Having the file servers only store the encrypted version of the files means that even if data from those servers are leaked, only members of the group the files belong to have access to the keys required to decrypt them. A new key is generated every time a member is removed from a group to ensure there is backward secrecy. All files will be encrypted with the most recent key, but no files need to be reencrypted with the new key. A removed member will still be able to decrypt these old files, but they could have just saved all files they had access to locally before their removal so there is no need to reencrypt them.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat7">
      <h2>Threat T7: Token Theft</h2>
<!-- BEGIN CHANGES HERE -->

<p>If we are not trusting file server admins, letting them gain access to tokens
which could be used to issue commands on any other server in the system is a massive
problem. A file server admin could collect a user's token and then use that token to
delete all the groups the user owns on the group server, or all the files the user has
access to on a different file server.</p>

<p>To prevent this, we will be adding a field to the token called target. The target
field will contain the fingerprint of the server's public key (defined in T3). The token's toString
method will be modified so that it includes this field in the unique identifier. The group server
will sign the token's toString after the target field has been filled, so any other server will
know if the field has been modified. Both the file server and the group server will verify the
signature and check that the target field matches their own public key's fingerprint. This does mean that if the
client wants to connect to a group server and a file server, they will need separate tokens.</p>

<p>This solution provides correctness and security. If the file server trusts the group
server's public key, then it should trust the token has not been modified if the token's
signature can be verified with the trusted public key. If the file server believes that
the token has not been modified, then the file server can trust that the token was created
to be used on their server if the target field of the token matches the fingerprint of their own public key.
With this solution in place, it would not be possible for a file server admin to collect
user's tokens and use them on any other server in the system. The file server admin would
need to obtain the group server's private key in order to change the target field and resign
the token.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->

<p>Conclude with a paragraph or two discussing the interplay between your
proposed mechanisms, and commenting on the design process that your group
followed. Did you discuss other ideas that didn’t pan out before settling on the
above-documented approach? Did you end up designing a really interesting
protocol suite that addresses multiple threats at once? Use this space to show
off your hard work!</p>

<p>Finally, spend about one paragraph convincing me that your modified protocols
still address the threats T1–T4 described in Phase 3 of the project.</p>

<p>If your group did any extra credit, please discuss that in this section, as
well.</p>

<!-- END CHANGES HERE -->
    </section>
  </body>
</html>

