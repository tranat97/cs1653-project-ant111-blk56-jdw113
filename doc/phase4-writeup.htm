<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P4 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired */
header {
  text-align: center;
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P4 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->
Andrew Tran: ant111@pitt.edu, Blaise Kesler: blk56@pitt.edu, Jeremy Wertkin: jdw113@pitt.edu
<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<p>We will use our previously defined handshake for file servers to
exchange keys with group servers. Instead of using a single key for
confidentiality, each session will have a confidentiality and an
integrity key. All messages sent after keys have been exchanged
will include an HMAC of the message data and the message number,
preventing message reorder, replay, or modification.</p>

<p>To protect against file leakage, we will be encrypting files
before they are sent to file servers. The group server will have
to manage keys for each group. When a group member is removed from
a group, the group server must generate a new key for that group.</p>

<p>To protect against token theft, tokens will have a new field that
contains the public key fingerprint of the server that the token is
supposed to be used on (this information is sent to the group server
by the client). The fingerprint will be included in the toString of
the token, preventing a rogue file server from modifying the field.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat5">
      <h2>Threat T5: Message Reorder, Replay, or Modification</h2>
<!-- BEGIN CHANGES HERE -->

<h3>Authenticating Group Servers:</h3>
<p>
In the current state of the project, the group server that the client connects to is not authenticated.  
The only requirement for a client to connect to a server is the IP address and port number of the server. 
This is not secure because without some way to authenticate the server, an attacker can intercept the traffic 
from a client, or multiple clients, going to the server through a man-in-the-middle attack. By intercepting the traffic, 
an attacker could impersonate the group server by spoofing their IP to match the actual group server.  
If a client sets up a connection with a malicious group server then the attacker could get username and password pairs.
This would be problematic because the attacker could then login to the actual group server with the stolen information.
</p>

<p>To prevent the issues explained above, we will use a public key fingerprint system similar to SSH 
using a 4096-bit RSA key pair to authenticate the group server. On the initial connection to a group server, 
the client will request the server's public key. The server will send their public key to the client and a 
hash of the key will be displayed to the client. The client must then decide whether or not to trust the key. 
Confirming the validity of the given key should be done through another secure channel.
We can assume that the client has a secure means of communicating with the file server admin 
because if they have agreed to manage groups and clients, they should have another channel to communicate.
If the client chooses to 
trust the key, a challenge is sent to the server from the client. This challenge will contain a random 256-bit nonce 
(r1) as well as two randomly generated AES keys, one for confidentiality and one for integrity.
The entire challenge is encrypted with the group server's public key. 
Next, the server must decrypt the challenge using their private key, generate another random nonce (r2), 
encrypt both nonces (r1 and r2) using the AES key generated by the client, and send the re-encrypted nonces back to the 
client. The client will then decrypt using their AES key to extract the nonces sent from the server and if the r1 sent from 
the server matches r1 that the client generated for the challenge, the client can be confident that the server they are 
connected to is the real group server. The client then sends r2 encrypted with the AES key back to the server. The 
server will then verify r2 and if successful, the server sends back an OK response and the handshake is complete. 
r2 is used to establish freshness. The client can then save the hash of the public key locally along with the IP address
of the group server. For every subsequent connection, if the hash value of the public key sent from the server matches 
a saved hash/IP public key, then the user is not asked if they trust the key.</p>

<ul>
    <li><em>k</em><sub>gs</sub>: Group server's public key</li>
    <li><em>k</em><sub>gs</sub><sup>-1</sup>: Group server's private key</li>
	<li><em>k</em><sub>AESc</sub>: AES Key for confidentiality</li>
	<li><em>k</em><sub>AESi</sub>: AES Key for integrity</li>
	<li><em>r1</em>: 256-bit Random nonce generated by the client</li>
	<li><em>r2</em>: 256-bit Random nonce generated by the file server</li>
</ul>
<ol>
    <li>GS &rarr; C: <em>k</em><sub>gs</sub></li>
	<li>C decides whether or not to trust <em>k</em><sub>gs</sub></li>
	<li>C generates <em>r1</em></li>
	<li>C generates <em>k</em><sub>AESc</sub> and <em>k</em><sub>AESi</sub></li>
    <li>C &rarr; GS: { <em>r1</em> || <em>k</em><sub>AESc</sub> || <em>k</em><sub>AESi</sub> }<em>k</em><sub>gs</sub></li>
	<li>GS decrypts { <em>r1</em> || <em>k</em><sub>AESc</sub>  || <em>k</em><sub>AESi</sub> }<em>k</em><sub>gs</sub> with <em>k</em><sub>gs</sub><sup>-1</sup></li>
	<li>GS generates <em>r2</em></li>
	<li>GS &rarr; C: { <em>r1</em> || <em>r2</em> }<em>k</em><sub>AESc</sub></li>
	<li>C decrypts { <em>r1</em> || <em>r2</em> }<em>k</em><sub>AESc</sub> with <em>k</em><sub>AESc</sub></li>
    <li>C checks for correct <em>r1</em></li>
	<li>C &rarr; GS: { <em>r2</em> }<em>k</em><sub>AESc</sub></li>
	<li>GS check for correct <em>r2</em></li>
	<li>GS &rarr; C: { "OK" }<em>k</em><sub>AESc</sub></li></li>
</ol>

<p>The only point of weakness in this mechanism is that a different secure channel is needed to validate the key 
the server's public key. If the group server and the user have not already established a shared symmetric
key or if the user doesn't already know the server's public key, there isn't a way to exchange this information that 
is secure against an active attacker. Relying on another secure channel and hoping users will personally verify public
keys is the best we can do. So, if we assume all users will verify public keys before trusting them, this mechanism will 
allow users to be confident that the host they are connected to is the real group server. We assume that the user has a 
secure means of communicating with the group server. The challenge system is a zero-knowledge proof that allows the group 
server to prove they know the private key that matches the trusted public key. Only the group server (who knows 
<em>k</em><sub>gs</sub><sup>-1</sup>) and the user will know confidentiality and integrity keys for the session so there is no way a man-in-the-middle can impersonate the group server.</p>

<h3>Preventing Message Reorder, Replay, or Modification:</h3>

<p>In the current state of the project, messages between the client and servers are sent encrypted, 
but order and modification cannot be detected. Messages can be modified, replayed, and reordered 
without consequence and this allows attackers with an easy way to harm and alter the system. Through 
launching a man-in-the-middle attack, an attacker could add deleted users back by replaying an add user 
command or reorder messages, so a user is deleted before they request to download a file.</p>

<p>This cannot happen in a secure file sharing system, so we will prevent these attacks by using ideas from TLS. 
First, we will concatenate a sequence number with the message we wish to send. This sequence number will have to 
be kept consistent between sender and receiver so that integrity can be properly checked. This can simply be done 
by having both client and server start at 1 and increment sequence number by one after each exchange. The sequence 
number will be reset to zero at the beginning of each client connection. Then we will take the HMAC of this 
concatenation of sequence number and message. The HMAC will be done using SHA2-256, as we need to use a 
cryptographically strong hashing algorithm. The HMAC will also require a 256-bit integrity key. This key will be 
generated at the same time as the confidentiality key. The exchange of these keys is shown in the previous diagram.
incorporate into the existing project because a second key can easily be sent along with the confidentiality key.
The message and HMAC will then be encrypted with the shared confidentiality key and sent to its destination.</p>

<p>With this system in place, every message sent after the handshake will look like:</p>
<ul>
	<li><em>k</em><sub>AESc</sub>: AES Key for confidentiality</li>
	<li><em>k</em><sub>AESi</sub>: AES Key for integrity</li>
	<li><em>i</em>: Message number</li>
	<li><em>m</em>: Message contents</li>
</ul>
<p>
C &rarr; S: { <em>m</em> }<em>k</em><sub>AESc</sub> ||
	HMAC( { <em>m</em> }<em>k</em><sub>AESc</sub> || <em>i</em>, <em>k</em><sub>AESi</sub> )
</p>


<p>This effectively addresses the security threats related to message reorder, replay, and modification.  
Messages cannot be modified because that will change the value of the HMAC, and the recipient of the altered message 
will recognize the attack and terminate the connection.  Messages cannot be reordered or replayed because both the 
sender and recipient will know the expected sequence, and this is incorporated into the HMAC. Therefore, if the 
sequence number is not the expected value, then the HMAC will not match and the connection will be terminated.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat6">
      <h2>Threat T6: File Leakage</h2>
<!-- BEGIN CHANGES HERE -->

<p>
Currently, all files that are stored on the file server are sent encrypted by the user using the session AES key.
However, the file server decrypts that file and stores the plaintext version of the file. Since the file servers
are not trusted, it cannot be assumed that files will not be leaked from these servers. It does not matter if
the transfer of the files from user to server is secure if the files can just be leaked from the server later on.
</p>

<p>
The solution to this problem is to have only the encrypted version of the files be sent and stored on the file
servers. Each file will be encrypted with a key unique to the group that the file belongs to. These keys will
be managed by the group server and will never be shared with the file servers. Each group's keys will be generated
by the group server and must be requested by users if they want to decrypt a file received from a file server.
A new key will be generated upon the group's creation and every time a member is removed from the group. Each
key will be identified with an integer value that represents which key is being used. For example, the very first
key will be key number 1, when a new key is generated, that key will be key number 2, etc. When a new file is being
uploaded to a file server, the user must request the most recent key generated, as well as the number corresponding
to that key. The user will encrypt the file using that key and send the encrypted version as well as the key number
to the file server where both will be saved. When downloading a file, the file server will send the encrypted file
as well as the key number associated with that file. The user will take that key number and request that specific
key from the group server which can be used to decrypt the file. Note: We are assuming that the file server will always
record the correct key number that is associated with the file being saved.
</p>

<ul>
    <li><em>k</em><sub>i</sub>: the group's i<sup>th</sup> key</li>
    <li><em>k</em><sub>n</sub>: the group's most recent key</li>
    <li><em>f</em>: the file</li>
	<li>Note: For the following examples, we assume the client (C) has
        permissions to access the keys and files requested. All messages are
		encrypted with the confidentiality session key and include the
		HMAC described in T5 using the integrity session key:</li>
</ul>
<p>Saving a file to the file server:</p>
<ol>
    <li>C &rarr; GS: request for <em>k</em><sub>n</sub></li>
    <li>GS &rarr; C: <em>k</em><sub>n</sub></li>
	<li>C &rarr; FS: { { f }<em>k</em><sub>n</sub> || n }</li>
</ol>

<p>Downloading a file from the file server:</p>
<ol>
    <li>FS &rarr; C: { { f }<em>k</em><sub>i</sub> || i }</li>
    <li>C &rarr; GS: request for <em>k</em><sub>i</sub></li>
    <li>GS &rarr; C: <em>k</em><sub>i</sub></li>
	<li>C decrypts { f }<em>k</em><sub>i</sub> with <em>k</em><sub>i</sub>
</ol>

<p>
Having the file servers only store the encrypted version of the files means that even if data from those servers are
leaked, only members of the group the files belong to have access to the keys required to decrypt them.
A new key is generated every time a member is removed from a group to ensure there is backward secrecy. We will also
add a timeout to tokens so that a user who has been removed from a group can not hold onto their token and do something
malicious like delete all the group's files. All files will be encrypted with the most recent key, but no files need
to be reencrypted with the new key. A removed member will still be able to decrypt these old files, but they could have
just saved all files they had access to locally before their removal so there is no need to reencrypt them.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat7">
      <h2>Threat T7: Token Theft</h2>
<!-- BEGIN CHANGES HERE -->

<p>If we are not trusting file server admins, letting them gain access to tokens
which could be used to issue commands on any other server in the system is a massive
problem. A file server admin could collect a user's token and then use that token to
delete all the groups the user owns on the group server, or all the files the user has
access to on a different file server.</p>

<p>To prevent this, we will be adding a field to the token called target. The target
field will contain the fingerprint of the server's public key (defined in T3). The token's toString
method will be modified so that it includes this field in the unique identifier. The group server
will sign the token's toString after the target field has been filled, so any other server will
know if the field has been modified. Both the file server and the group server will verify the
signature and check that the target field matches their own public key's fingerprint. This does mean that if the
client wants to connect to a group server and a file server, they will need separate tokens.</p>

<p>This solution provides correctness and security. If the file server trusts the group
server's public key, then it should trust the token has not been modified if the token's
signature can be verified with the trusted public key. If the file server believes that
the token has not been modified, then the file server can trust that the token was created
to be used on their server if the target field of the token matches the fingerprint of their own public key.
With this solution in place, it would not be possible for a file server admin to collect
user's tokens and use them on any other server in the system. The file server admin would
need to obtain the group server's private key in order to change the target field and resign
the token.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->

<p>There is not as much interplay with these proposed mechanisms as there
were with our protocols designed for phase 3. The changes described in T5
affect every message sent, which will have an effect on T6 and T7</p>

<p>Before beginning to write this document, our group met to discuss
possible solutions. We identified our solution for T7 almost immediately,
but the others took more time. It wasn't until after the lectures on TLS
that we were able to figure out a simple solution to T5. Our first
solution to T6 was far too inefficient. When a group member was removed,
we were planning on downloading all the files from the file server,
decrypting them with the old key, encrypting them with the new key,
and then uploading them back to the file server. Professor Garrison
mentioned lazy revocation in discord, and we decided that was a much
better solution.</p>

<p>T1 is still protected against because clients still have to
authenticate with a password in order to obtain a token. Tokens
are being signed by the group server, so our solution for
T2 is still in effect. Our handshake with file servers has not
changed (except we are sending two keys instead of one), so
our solution for T3 still applies.
Every message sent is being encrypted, so there should not be any
information leakage (T4).</p>

<!-- END CHANGES HERE -->
    </section>
  </body>
</html>

