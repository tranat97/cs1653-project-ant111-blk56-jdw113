<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P4 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired */
header {
  text-align: center;
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P4 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->
Andrew Tran: ant111@pitt.edu, Blaise Kesler: blk56@pitt.edu, Jeremy Wertkin: jdw113@pitt.edu
<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<p>In this section, broadly overview the types of cryptographic techniques that
your group has decided to use to address threats T5–T7.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat5">
      <h2>Threat T5: Message Reorder, Replay, or Modification</h2>
<!-- BEGIN CHANGES HERE -->

<p>Authenticating Group Servers:
<br>
In the current state of the project, the group server that the client connects to is not authenticated.  
The only requirement for a user to connect to a server is the IP address and port number of the server. 
This is not secure because without some way to authenticate the server, an attacker can intercept the traffic 
from a user, or multiple users, going to the server through a man-in-the-middle attack. By intercepting the traffic, 
an attacker could impersonate the group server by spoofing their IP to match the actual group server.  
If a client sets up a connection with a malicious group server then the attacker could get username and password pairs.
This would be problematic because the attacker could then login to the actual group server with the stolen information.
</p>

<p>To prevent the issues explained above, we will use a public key authentication system similar to SSH 
using a 4096-bit RSA key pair to authenticate the group server. On the initial connection to a file server, 
the user will request the server's public key. The host will send their public key to the user and a truncated 
hash of the key will be displayed to the user. The user must then decide whether or not to trust the key. 
Confirming the validity of the given key should be done through another secure channel. If the user chooses to 
trust the key, a challenge is sent to the host from the user. This challenge will contain a random 256-bit nonce 
(r1) as well as a randomely generated AES key. The entire challenge is encrypted with the group server's public key. 
For each challenge, the host must decrypt the challenge using their private key, generate another random nonce (r2), 
encrypt both nonces (r1 and r2) using the AES key generated by the user, and send the re-encrypted nonces back to the 
user. The user will then decrypt using their AES key to extract the nonces sent from the host and if the r1 sent from 
the host matches r1 that the user generated for the challenge, the user can be confident that the host they are 
connected to is the real group server.  The user then sends r2 encryprted with the AES key back to the server. The 
server will then verify r2 and if successful, the server sends back an OK response and the challenge is complete. 
r2 is used to establish freshness. The user can then save the hash of the public key locally along with the IP address
of the group server. For every subsequent connection, if the hash value of the public key sent from the host matches 
a saved hash/IP public key verification is skipped.</p>

<ul>
    <li><em>k</em><sub>gs</sub>: Group server's public key</li>
    <li><em>k</em><sub>gs</sub><sup>-1</sup>: Group server's private key</li>
	<li><em>k</em><sub>AES</sub>: AES Key</li>
	<li><em>r1</em>: 256-bit Random nonce generated by the user</li>
	<li><em>r2</em>: 256-bit Random nonce generated by the file server</li>
</ul>
<ol>
    <li>GS &rarr; C: <em>k</em><sub>gs</sub></li>
	<li>C decides whether or not to trust <em>k</em><sub>gs</sub></li>
	<li>C generates <em>r1</em></li>
	<li>C generates <em>k</em><sub>AES</sub></li>
    <li>C &rarr; GS: { <em>r1</em> || <em>k</em><sub>AES</sub> }<em>k</em><sub>gs</sub></li>
	<li>GS decrypts { <em>r1</em> || <em>k</em><sub>AES</sub> }<em>k</em><sub>gs</sub> with <em>k</em><sub>fs</sub><sup>-1</sup></li>
	<li>GS generates <em>r2</em></li>
	<li>GS &rarr; C: { <em>r1</em> || <em>r2</em> }<em>k</em><sub>AES</sub></li>
	<li>C decrypts { <em>r1</em> || <em>r2</em> }<em>k</em><sub>AES</sub> with <em>k</em><sub>AES</sub></li>
    <li>C checks for correct <em>r1</em></li>
	<li>C &rarr; GS: { <em>r2</em> }<em>k</em><sub>AES</sub></li>
	<li>GS check for correct <em>r2</em></li>
	<li>GS &rarr; C: { "OK" }<em>k</em><sub>AES</sub></li></li>
</ol>

<p>The only point of weakness in this mechanism is that a different secure channel is needed to validate the key 
and is also not required to do so. If the group server and the user have not already established a shared symmetric
key or if the user doesn't already know the server's public key, there isn't a way to exchange this information that 
is secure against an active attacker. Relying on another secure channel and hoping users will personally verify public
keys is the best we can do. So, if we assume all users will verify public keys before trusting them, this mechanism will 
allow users to be confident that the host they are connected to is the real group server. We assume that the user has a 
secure means of communicating with the group server. The challenge system is a zero-knowledge proof that allows the group 
server to prove they know the private key that matches the trusted public key. Only the group server (who knows kfs-1) and 
the user will know the kAES for the session so there is no way a man-in-the-middle can impersonate the group server.</p>


<p>Preventing Message Reorder, Replay, or Modification:
<br>
In the current state of the project, messages between the client and servers are sent encrypted, 
but order and modification cannot be detected.  Messages can be modified, replayed, and reordered 
without consequence and this allows attackers with an easy way to harm and alter the system.  Through 
launching a man-in-the-middle attack, an attacker could add deleted users back by replaying an add user 
command or reorder messages, so a user is deleted before they request to download a file.</p>

<p>This cannot happen in a secure file sharing system, so we will prevent these attacks by using ideas from TLS. 
First, we will concatenate a sequence number with the message we wish to send.  This sequence number will have to 
be kept consistent between sender and receiver so that integrity can be properly checked. This can simply be done 
by having both client and server start at 1 and increment sequence number by one after each exchange.  The sequence 
number will be reset to zero at the beginning of each client connection.  Then we will take the HMAC of this 
concatenation of sequence number and message.  The HMAC will be done using SHA2-256, as we need to use a 
cryptographically strong hashing algorithm.  The HMAC will also require a 64-byte integrity key.  This key will be 
generated at the same time as the AES key.  For group server-client communication, the group server will generate the 
integrity key.  For file server-client communication, the client will generate the integrity key.  It will be easy to 
incorporate into the existing project because a second key can easily be sent along with the AES key.  The message and 
HMAC will then be encrypted with the shared AES key and sent to its destination.</p>

<p>(ADD CHART)</p>

<p>This effectively address the security threats related to message reorder, replay, and modification.  
Messages cannot be modified because that will change the value of the HMAC, and the recipient of the altered message 
will recognize the attack and terminate the connection.  Messages cannot be reordered or replayed because both the 
sender and recipient will know the expected sequence, and this is incorporated into the HMAC.  Therefore, if the 
sequence number is not the expected value, then the HMAC will not match and the connection will be terminated.</p>
<!-- END CHANGES HERE -->
    </section>
    <section id="threat6">
      <h2>Threat T6: File Leakage</h2>
<!-- BEGIN CHANGES HERE -->

<!--<p>Begin this section by describing threat T6. This may include describing
examples of the threat being exploited by an adversary, a short discussion of
why this threat is problematic and needs to be addressed, and/or diagrams
showing how the threat might manifest in your group’s implementation from Phase
3.</p> -->

<p>
Currently, all files that are stored on the file server are sent ecrypted by the user using the session AES key. However, the file server decrypts that file and stores the plaintext version of the file. Since the file servers are not trusted, it cannot be assumed that files will not be leaked from these servers. So it does not matter if the transfer of the files from user to server is secure if the files can just be leaked from the server later on.
</p>

<!--<p>Next, provide a short description of the mechanism that you chose to
implement to protect against this threat. For interactive protocols, it would be
helpful to provide a diagram explaining the messages exchanged between
participating principals (use html &lt;img&gt; tag to import such images). Be
sure to explain any cryptographic choices that your group makes: What types of
algorithms, modes of operation, and/or key lengths did you choose? Why? If
shared keys are needed, how are they exchanged?</p> -->

<p>
The solution to this problem is to have only the encrypted version of the files be sent and stored on the file servers. Each file will be encrypted with a key unique to the group that the file belongs to. These keys will be managed by the group server and will never be shared with the file servers. Each group's keys will be generated by the group server and must be requested by users if they want to decrypt a file recieved from a file server. A new key will be generated upon the group's creation and every time a member is removed from the group. Each key will be identified with an integer value that represents which key is being used. For example, the very first key will be key number 1, when a new key is generated, that key will be key number 2, etc. When a new file is being uploaded to a file server, the user must request the most recent key generated, as well as the number corresponding to that key. The user will encrypt the file using that key and send the encrypted version as well as the key number to the file server where both will be saved. When downloading a file, the file server will send the encrypted file as well as the key number associated with that file. The user will take that key number and request that specific key from the group server which can be used to decrypt the file. Note: We are assuming that the file server will always record the correct key number that is associated with the file being saved.
</p>

<ul>
    <li><em>k</em><sub>i</sub>: the group's i<sup>th</sup> key</li>
    <li><em>k</em><sub>n</sub>: the group's most recent key</li>
    <li><em>f</em>: the file</li>
	<li>Note: For the following examples, we assume the user (C) has permissions to access the keys requested and all messages are encrypted with the appropriate session keys:</li>
</ul>
<p>Saving a file to the file server:</p>
<ol>
    <li>C &rarr; GS: request for <em>k</em><sub>n</sub></li>
    <li>GS &rarr; C: <em>k</em><sub>n</sub></li>
	<li>C &rarr; FS: { { f }<em>k</em><sub>n</sub> || n }</li>
</ol>

<p>Downloading a file from the file server:</p>
<ol>
    <li>FS &rarr; C: { { f }<em>k</em><sub>i</sub> || i }</li>
    <li>C &rarr; GS: request for <em>k</em><sub>i</sub></li>
    <li>GS &rarr; C: <em>k</em><sub>i</sub></li>
	<li>C decrypts { f }<em>k</em><sub>i</sub> with <em>k</em><sub>i</sub>
</ol>

<!--<p>Finally, provide a short argument addressing why your proposed mechanism
sufficiently addresses this particular threat. This argument should address the
correctness of your approach, as well as its overall security. For example, if
your mechanism involves a key agreement or key exchange protocol, you should
argue that both parties agree on the same key (correctnes) and that no other
party can figure out the key (security).</p>-->

<p>
Having the file servers only store the encrypted version of the files means that even if data from those servers are leaked, only members of the group the files belong to have access to the keys required to decrypt them. A new key is generated every time a member is removed from a group to ensure there is backward secrecy. All files will be encrypted with the most recent key, but no files need to be reencrypted with the new key. A removed member will still be able to decrypt these old files, but they could have just saved all files they had access to locally before their removal so there is no need to reencrypt them.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat7">
      <h2>Threat T7: Token Theft</h2>
<!-- BEGIN CHANGES HERE -->

<p>If we are not trusting file server admins, letting them gain access to tokens
which could be used to issue commands on any other server in the system is a massive
problem. A file server admin could collect a user's token and then use that token to
delete all the groups the user owns on the group server, or all the files the user has
access to on a different file server.</p>

<p>To prevent this, we will be adding a field to the token called target. The target
field will contain the fingerprint of the server's public key (defined in T3). The token's toString
method will be modified so that it includes this field in the unique identifier. The group server
will sign the token's toString after the target field has been filled, so any other server will
know if the field has been modified. Both the file server and the group server will verify the
signature and check that the target field matches their own public key's fingerprint. This does mean that if the
client wants to connect to a group server and a file server, they will need separate tokens.</p>

<p>This solution provides correctness and security. If the file server trusts the group
server's public key, then it should trust the token has not been modified if the token's
signature can be verified with the trusted public key. If the file server believes that
the token has not been modified, then the file server can trust that the token was created
to be used on their server if the target field of the token matches the fingerprint of their own public key.
With this solution in place, it would not be possible for a file server admin to collect
user's tokens and use them on any other server in the system. The file server admin would
need to obtain the group server's private key in order to change the target field and resign
the token.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->

<p>Conclude with a paragraph or two discussing the interplay between your
proposed mechanisms, and commenting on the design process that your group
followed. Did you discuss other ideas that didn’t pan out before settling on the
above-documented approach? Did you end up designing a really interesting
protocol suite that addresses multiple threats at once? Use this space to show
off your hard work!</p>

<p>Finally, spend about one paragraph convincing me that your modified protocols
still address the threats T1–T4 described in Phase 3 of the project.</p>

<p>If your group did any extra credit, please discuss that in this section, as
well.</p>

<!-- END CHANGES HERE -->
    </section>
  </body>
</html>

